/*
 * Conflux C++ Library - FFI Bridge
 *
 * This file provides C++ wrappers around the C FFI functions.
 *
 * License: MIT OR Apache-2.0
 */

#include "ffi_bridge.hpp"

// The conflux_ffi.h header is generated by cbindgen during the Rust build
extern "C" {
#include "conflux_ffi.h"
}

namespace conflux {
namespace ffi {

SynchronizerHandle create_synchronizer(uint64_t window_size_ms, size_t buffer_size,
                                       const std::vector<std::string>& topics) {
    ConfluxConfig config;
    config.window_size_ms = window_size_ms;
    config.buffer_size = buffer_size;

    // Convert topics to C strings
    std::vector<const char*> topic_ptrs;
    topic_ptrs.reserve(topics.size());
    for (const auto& topic : topics) {
        topic_ptrs.push_back(topic.c_str());
    }

    auto* ptr = conflux_synchronizer_new(&config, topic_ptrs.data(), topic_ptrs.size());

    return SynchronizerHandle{ptr};
}

void destroy_synchronizer(SynchronizerHandle handle) {
    if (handle.ptr) {
        conflux_synchronizer_free(handle.ptr);
    }
}

PushResult push_message(SynchronizerHandle handle, const std::string& topic, int64_t timestamp_ns,
                        void* user_data) {
    if (!handle.ptr) {
        return PushResult::NullPointer;
    }

    auto result = conflux_push_message(handle.ptr, topic.c_str(), timestamp_ns, user_data);

    switch (result) {
        case ConfluxResult_Ok:
            return PushResult::Ok;
        case ConfluxResult_BufferFull:
            return PushResult::BufferFull;
        case ConfluxResult_KeyNotFound:
            return PushResult::KeyNotFound;
        case ConfluxResult_InvalidArgument:
            return PushResult::InvalidArgument;
        case ConfluxResult_NullPointer:
            return PushResult::NullPointer;
        default:
            return PushResult::InternalError;
    }
}

bool poll(SynchronizerHandle handle, PollCallback callback, void* context) {
    if (!handle.ptr) {
        return false;
    }

    // Wrap the callback
    struct CallbackWrapper {
        PollCallback callback;
        void* context;
    };

    CallbackWrapper wrapper{callback, context};

    auto c_callback = [](const char* key, int64_t timestamp_ns, void* user_data, void* context) {
        auto* wrapper = static_cast<CallbackWrapper*>(context);
        wrapper->callback(key, timestamp_ns, user_data, wrapper->context);
    };

    int result = conflux_poll(handle.ptr, c_callback, &wrapper);
    return result > 0;
}

size_t key_count(SynchronizerHandle handle) {
    if (!handle.ptr) {
        return 0;
    }
    return conflux_key_count(handle.ptr);
}

bool is_ready(SynchronizerHandle handle) {
    if (!handle.ptr) {
        return false;
    }
    return conflux_is_ready(handle.ptr);
}

bool is_empty(SynchronizerHandle handle) {
    if (!handle.ptr) {
        return true;
    }
    return conflux_is_empty(handle.ptr);
}

size_t buffer_len(SynchronizerHandle handle, const std::string& topic) {
    if (!handle.ptr) {
        return 0;
    }
    return conflux_buffer_len(handle.ptr, topic.c_str());
}

}  // namespace ffi
}  // namespace conflux
