/*
 * Conflux FFI - C bindings for multi-stream message synchronization
 *
 * This header is auto-generated by cbindgen. Do not edit manually.
 *
 * License: MIT OR Apache-2.0
 */


#ifndef CONFLUX_FFI_H
#define CONFLUX_FFI_H

/* Generated with cbindgen:0.29.2 */

/* Warning: this file is auto-generated by cbindgen. Don't modify manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Result codes for FFI operations.
 */
typedef enum ConfluxResult {
  /**
   * Operation succeeded.
   */
  ConfluxResult_Ok = 0,
  /**
   * Invalid argument provided.
   */
  ConfluxResult_InvalidArgument = 1,
  /**
   * Buffer is full, message rejected.
   */
  ConfluxResult_BufferFull = 2,
  /**
   * Key not found.
   */
  ConfluxResult_KeyNotFound = 3,
  /**
   * Null pointer provided.
   */
  ConfluxResult_NullPointer = 4,
  /**
   * Internal error.
   */
  ConfluxResult_InternalError = 5,
} ConfluxResult;

/**
 * Opaque handle to a synchronizer instance.
 *
 * The synchronizer manages multiple message streams and outputs
 * synchronized groups when messages fall within the configured time window.
 */
typedef struct ConfluxSynchronizer ConfluxSynchronizer;

/**
 * Configuration for creating a synchronizer.
 */
typedef struct ConfluxConfig {
  /**
   * Time window in milliseconds for grouping messages.
   */
  uint64_t window_size_ms;
  /**
   * Maximum number of messages to buffer per stream.
   */
  uintptr_t buffer_size;
} ConfluxConfig;

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

/**
 * Create a new synchronizer with the given configuration and keys.
 *
 * # Safety
 *
 * - `keys` must be an array of `key_count` valid null-terminated C strings.
 * - Returns a pointer to a new synchronizer instance. The caller is responsible
 *   for freeing this with `conflux_synchronizer_free`.
 */
struct ConfluxSynchronizer *conflux_synchronizer_new(const struct ConfluxConfig *config,
                                                     const char *const *keys,
                                                     uintptr_t key_count);

/**
 * Free a synchronizer instance.
 *
 * # Safety
 *
 * The pointer must have been returned by `conflux_synchronizer_new` and must
 * not be used after this call.
 */
void conflux_synchronizer_free(struct ConfluxSynchronizer *sync);

/**
 * Push a message to the synchronizer.
 *
 * # Safety
 *
 * - `sync` must be a valid pointer from `conflux_synchronizer_new`.
 * - `key` must be a valid null-terminated C string for a key provided at creation.
 * - `user_data` is an opaque pointer that will be returned in synchronized groups.
 *
 * # Returns
 *
 * - `ConfluxResult::Ok` if the message was accepted.
 * - `ConfluxResult::BufferFull` if the buffer for this key is full.
 * - `ConfluxResult::KeyNotFound` if the key was not provided at creation.
 */
enum ConfluxResult conflux_push_message(struct ConfluxSynchronizer *sync,
                                        const char *key,
                                        int64_t timestamp_ns,
                                        void *user_data);

/**
 * Poll for a synchronized group of messages.
 *
 * This function checks if there's a complete synchronized group available
 * and returns it via the callback.
 *
 * # Safety
 *
 * - `sync` must be a valid pointer from `conflux_synchronizer_new`.
 * - `callback` will be called with each key-value pair in the synchronized group.
 * - `context` is passed through to the callback.
 *
 * # Callback
 *
 * The callback receives:
 * - `key`: The topic/key name (null-terminated string)
 * - `timestamp_ns`: Message timestamp in nanoseconds
 * - `user_data`: The user data pointer passed to `conflux_push_message`
 * - `context`: The context pointer passed to this function
 *
 * # Returns
 *
 * - 1 if a synchronized group was found and callback was invoked.
 * - 0 if no synchronized group is available.
 * - -1 on error.
 */
int32_t conflux_poll(struct ConfluxSynchronizer *sync,
                     void (*callback)(const char *key,
                                      int64_t timestamp_ns,
                                      void *user_data,
                                      void *context),
                     void *context);

/**
 * Get the number of keys registered with the synchronizer.
 *
 * # Safety
 *
 * `sync` must be a valid pointer from `conflux_synchronizer_new`.
 */
uintptr_t conflux_key_count(const struct ConfluxSynchronizer *sync);

/**
 * Check if the synchronizer is ready (all buffers have at least 2 messages).
 *
 * # Safety
 *
 * `sync` must be a valid pointer from `conflux_synchronizer_new`.
 */
bool conflux_is_ready(const struct ConfluxSynchronizer *sync);

/**
 * Check if the synchronizer is empty (any buffer is empty).
 *
 * # Safety
 *
 * `sync` must be a valid pointer from `conflux_synchronizer_new`.
 */
bool conflux_is_empty(const struct ConfluxSynchronizer *sync);

/**
 * Get the buffer size for a specific key.
 *
 * # Safety
 *
 * - `sync` must be a valid pointer from `conflux_synchronizer_new`.
 * - `key` must be a valid null-terminated C string.
 *
 * # Returns
 *
 * The number of messages in the buffer, or 0 if the key is not found.
 */
uintptr_t conflux_buffer_len(const struct ConfluxSynchronizer *sync, const char *key);

#ifdef __cplusplus
}  // extern "C"
#endif  // __cplusplus

#endif  /* CONFLUX_FFI_H */
